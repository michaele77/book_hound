
# This file is simple for providing the BookNode and UserNode functions, and any surrounding functionality around that
# This is to reduce clutter in the thread_spinner.py file

# NOTES

# Why does bookNode have a reviewers list, but userNode doesnt have a reviewers list?
#       Ultimately, bookNode's user list is the important one here as it determines the relevance or 'score' of the book by summing the users' rated scores
#       It made sense to me to include a seperate reviewers list as a way to ultimately keep track of which users were generated by which books
#       The only reason the user node has a books list is in case we want to iterate through a book's raters list, and look at all the books they rated as a sort of secondary net crawl
#       This is a small feature and it doesnt make sense to me to have a whole seperate reviewed books list for each user

class BookNode:
    def __init__(self, input_book_info):
        self.ID                 = input_book_info['ID']
        self.title              = input_book_info['title']
        self.href               = input_book_info['href']

        # NOTE: These 2 lists are coupled...use a shared index between them to access the ID or the instance itself
        self.raters             = [] #will track which users have rated this book (for traversal)
        self.raters_ID          = [] #keeps track of users through unique user ID

        # All parameters below are functions of a fully defined book, set params to 0 for now to reserve them
        # Setting them to "NONE" makes them not picklable
        # NOTE: These 2 lists are coupled...use a shared index between them to access the ID or the instance itself
        self.reviewers          = 0
        self.reviewers_ID       = 0

        self.author             = 0
        self.meta               = 0
        self.details            = 0
        self.series             = 0
        self.summary            = 0
        self.imageSource        = 0
        self.imageBinary        = 0
        self.genres             = 0

        # the following tells you whether this book node has the full information or not
        # when all scraping is done, we can go back and see which nodes dont have this flag set and collect info for it
        # The parameters missing for this would be summary, imageSource, meta, details ,series, imageBinary, and genres
        self.has_full_params    = 0


    def add_full_book_info(self, input_book_info):
        self.author = input_book_info['author']
        self.meta = input_book_info['meta']
        self.details = input_book_info['details']
        self.series = input_book_info['series']
        self.summary = input_book_info['summary']
        self.imageSource = input_book_info['imageSource']
        self.imageBinary = input_book_info['imageBinary']
        self.genres = input_book_info['genres']

        self.has_full_params = 1


    def add_reviewers(self, input_reviewers_list):
        # Unfortunately, I'm too lazy to store the reviewers' score...shouldn't affect the algo too much...
        self.reviewers = []
        self.reviewers_ID = []
        for curr_rev in input_reviewers_list:
            self.reviewers.append(curr_rev)
            self.reviewers_ID.append(curr_rev.ID)



    def add_rater(self, input_rater, input_rater_score):
        inTuple = (input_rater, input_rater_score)
        self.raters.append(inTuple)
        self.raters_ID.append(input_rater.ID)




class UserNode:
    def __init__(self, input_reviewer_info):
        self.ID             = input_reviewer_info['ID']
        self.name           = input_reviewer_info['name']
        self.link           = input_reviewer_info['link']
        self.ratingsLink    = input_reviewer_info['ratings link']
        self.ratings        = input_reviewer_info['ratings'] #contains raw raters book list
        self.match_score    = 1

        # NOTE: These 2 lists are coupled...use a shared index between them to access the ID or the instance itself
        self.books          = [] #this variable will filter the self.ratings data, and will assign
        self.books_ID       = [] #keeps track of books through unique book ID

    # If adding reviewers, use this same function
    # To keep the same structure, add as a 4.5 (which also differentiates it from a simple add_rater)
    def add_book(self, input_book, input_score):
        inTuple = (input_book, input_score)
        self.books.append(inTuple)
        self.books_ID.append(input_book.ID)



